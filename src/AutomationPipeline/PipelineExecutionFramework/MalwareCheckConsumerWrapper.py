import sys, os

PROJ_ROOT_FOLDER = os.environ['GLEAN_PATH']
if not PROJ_ROOT_FOLDER in sys.path:
    sys.path.append(PROJ_ROOT_FOLDER)

from PipelineExecutionFramework import ConsumerWrapper
from GleanMongoDB import Malware, MalwareManager
import multiprocessing, threading

from ENV import DEFAULT_MALWARE_COLLECTION_NAME

class MalwareCheckConsumerWrapper(ConsumerWrapper):
    def __init__(self, topic, bootstrap_servers=["localhost:9092"], thread_name=None) -> None:
        super().__init__(topic, bootstrap_servers, thread_name=thread_name)
        self.malware_manager = None  
        self.malware = None

        
    def init_after_pickle(self, init_malware_manager=True, malware_collection_name=None) -> bool:
        if super().init_after_pickle():
            if init_malware_manager:
                malware_collection_name = DEFAULT_MALWARE_COLLECTION_NAME if malware_collection_name == None else malware_collection_name
                self.malware_manager= MalwareManager(malware_collection_name=malware_collection_name)
            return True
        else:
            return False
        
    def pre_process(self, job):
        self.malware = Malware(job)
                
        latest = self.malware_manager.get_malware(self.malware)
        if not latest:
            latest = job
            # raise Exception("Malware not found")
        if 'idle' in latest  and latest['idle'] == False:
            raise Exception("Malware is not idle")
        self.malware = Malware(latest)
        
        self.malware.idle = False
        self.malware_manager.update_malware(self.malware)
        
        return None
    
    def process(self, job):
        pass
    
    def post_process(self, job):
        # result collection, data log, and gracely finish
        pass
    
    def finish(self):
        if self.malware != None:
            self.malware.idle = True
            self.malware_manager.update_malware(self.malware)
    
    def handle_failure(self,e:Exception=None):
        print(e)
        #  for any exception, we should update the malware info and graceful finish it. 
        # finish() is still called after exception
        pass    
        
    def run_job(self, job):
        print(str(job) + " on " + multiprocessing.current_process().name + " thread: " + str(threading.current_thread().name))
        try:
            self.pre_process(job)
            self.process(job)
            self.post_process(job)
        except Exception as e:
            self.handle_failure(e)
            # return True    
        finally:
            self.finish()
        return True
    
    
    
    'java -jar /home/abhishek/workplace/ProjDropperChain/FlowDroidPipeline/flowDroid.jar -a /ra2/RESULTS_2022/unpack_repack_binaries/932cb0c77eaff4f815995f9cf7d4cbd5a62ecd12f990bbd212c709e9a19e4f75.apk -p /usr/lib/android-sdk/platforms  -s /home/abhishek/workplace/ProjDropperChain/FlowDroidPipeline/sourceNSinkFiles/dcl_sink.txt -o /ra2/RESULTS_2022/flowdroid_dcl_results/932cb0c77eaff4f815995f9cf7d4cbd5a62ecd12f990bbd212c709e9a19e4f75.json -of json  --mergedexfiles -dl -ot --paths -logcall ---extraentrypoint /ra2/RESULTS_2022/unpack_results/932cb0c77eaff4f815995f9cf7d4cbd5a62ecd12f990bbd212c709e9a19e4f75/bridge.json'